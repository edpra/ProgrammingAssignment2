## Matrix inversion is usually a costly computation and there may be some benefit
## to caching the inverse of a matrix rather than computing it repeatedly.
## This module contains functions that calculate and cache the inverse of a matrix
##
## To run test cases try the following:
##
## > source("cachematrix.R")
## > runTestcases()
##
## runTestcases() is a test function that run two test cases to excercise
## functions in this module

## makeCacheMatrix() contains a list a getter/setter functions
##   to store a matrix and its inverse
## 
## Input Parameter
##   gm - is the matrix to store in cache.  gm must be an invertible matrix.
##        no checking is done to see if gm is convertible or not
##
## Output - a list of the following functions
##
## Functions
## - set(y) - is the matrix to store in cache
## - get()  - returns the stored matrix
## - setInverse(inv) - inv is an inverted matrix to store in cache
## - getInverse()    - return the stored inverted matrix
##
## Assumptions: 
##   - set() is just a setter function.  It does not calculate
##     the matrix to the inverted matrix.  
##   - setInverse() also ignore the stored matrix
##
makeCacheMatrix <- function(gm = matrix()) {
    gminv <- NULL

    set <- function(y=matrix()) {
        gm <<- y                   ## store matrix in GE
        gminv <<- NULL             ## set the inverted matrix to NULL
    }
    get <- function() gm
    setInverse <- function(inv) gminv <<- inv
    getInverse <- function()    gminv
    
    ## returns a list of getter/setter functions
    list(set = set, get = get, setInverse = setInverse, getInverse = getInverse)
}


## cacheSolve() receives a matrix generated by makeCacheMatrix() and 
##   calculates its inverted matrix and store the inverted matrix in cache.
##   This functions returns the inverted inverted matrix if it is already in the cache.
##   If not a new inverted matrix is created, stored in cache and returned.
##
## Input Parameter
##   x - matrix that was generated by makeCacheMatrix()
##
## Output - return a matrix that is the inverse of 'x'
##
cacheSolve <- function(x, ...) {
    ## Return a matrix that is the inverse of 'x'
    inv <- x$getInverse()
    if(!is.null(inv)) {
        message("getting cached data")
        return(inv)
    }
    data <- x$get()
    inv <- solve(data, ...)
    x$setInverse(inv)
    inv  ## return the inverted matrix
}


## function to excercise makeCacheMatrix and cacheSolve
runTestcases <- function() {
    tc1 <- function() {   ## case 1 - simple 2x2 matrix
        print("----- TEST CASE 1 -----")
        m <- matrix(1:4, 2, 2)
        cm <- makeCacheMatrix(m)
        print("    solving for inversion of matrix:")
        print(cm$get())             ## test get()
        ci <- cacheSolve(cm)
        print("    inversion:")
        print(ci)                   ## test getInverse()
        if (all.equal(cm$getInverse(), matrix(c(-2, 1, 1.5,-0.5), 2, 2)) == T)
            print("    -- result as expected")
        else
            print("    -- FAILED")
        print("    solving inversion again")
        cacheSolve(cm)
        if (all.equal(ci, matrix(c(-2, 1, 1.5,-0.5), 2, 2)) == T)
            print("    -- result as expected")
        else
            print("    -- FAILED")
        #####
        m <- matrix(9:6, 2, 2)
        cm$set(m)                   ## test set()
        print("    solving for inversion of a new matrix:")
        print(cm$get())             ## test get()
        ci <- cacheSolve(cm)
        print("    inversion:")
        print(ci)                   ## test getInverse()
    }
    tc2 <- function(iter, mdim) { ## case 2 - non-trivial matrix >= 500x500 numerics
        print(paste("----- TEST CASE 2 ----- iteration: ", iter))
        set.seed(1234567)
        
        ## mdim <- 500
        cm <- makeCacheMatrix(matrix(rnorm(mdim*mdim), mdim, mdim))
        start <- Sys.time()
        cacheSolve(cm)
        lapsed1 <- Sys.time() - start

        start <- Sys.time()
        cacheSolve(cm)
        lapsed2 <- Sys.time() - start
        
        ## return the two time lapses
        cbind(lapsed1, lapsed2)
    }
    
    ## simple test case
    tc1()
    
    ## timimg test case
    mdim <- 500
    print(paste0("----- Test case 2 - Solving inversion of a ", mdim, "x", mdim, " matrix of rnorm values"))
    durations <- lapply(1:10, tc2, mdim)
    mdur <- matrix(unlist(durations), nrow=length(durations), byrow=T, dimnames=list(c(),c("nonCached","cached")))
    print(sprintf("Average non-cached calculation time: %.2f milliseconds", mean(mdur[,"nonCached"])*1000))
    print(sprintf("Average cached calculation time:     %.2f milliseconds", mean(mdur[,"cached"])*1000))
    ## mdur
}
